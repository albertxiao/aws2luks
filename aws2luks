#!/bin/bash

wait_for_volume()
{
    VOLUME=$1
    WAIT_STATE=$2

    while true
    do
        aws ec2 describe-volumes --volume-ids=$VOLUME > info 2> /dev/null
        STATE=$(jq -r '.Volumes[].State' < info)
        test -z "$STATE" && break
        test "$STATE" == "$WAIT_STATE" && break
        sleep 1
    done

    rm info
}

wait_for_snapshot()
{
    SNAPSHOT=$1
    WAIT_STATE=$2

    while true
    do
        aws ec2 describe-snapshots --snapshot-ids=$SNAPSHOT > info 2> /dev/null
        STATE=$(jq -r '.Snapshots[].State' < info)
        test -z "$STATE" && break
        test "$STATE" == "$WAIT_STATE" && break
        sleep 1
    done

    rm info
}

wait_for_image()
{
    IMAGE=$1
    WAIT_STATE=$2

    while true
    do
        aws ec2 describe-images --image-ids=$IMAGE > info 2> /dev/null
        STATE=$(jq -r '.Images[].State' < info)
        test -z "$STATE" && break
        test "$STATE" == "$WAIT_STATE" && break
        sleep 1
    done

    rm info
}

wait_for_instance()
{
    INSTANCE=$1

    while true
    do
        aws ec2 describe-instances --instance-ids=$INSTANCE > info
        STATE=$(jq -r '.Reservations[].Instances[].State.Name' < info)
        test -z "$STATE" && fail "Instance was not created"

        if [[ "$STATE" == "running" ]]
        then
            PUBLIC_IP=$(jq -r '.Reservations[].Instances[].PublicIpAddress' < info)

            echo "Instance $INSTANCE is running"
            echo "SSH to $PUBLIC_IP as root to boot the system"
            break
        fi

        sleep 1
    done

    rm info
}

wait_for_device()
{
    DEVICE=$1

    while true
    do
        test -e $DEVICE && break
        sleep 1
    done
}

volume_cleanup()
{
    test $VOLUME_CLEANUP_DONE -eq 1 && return

    test -e $WORK_DIR/setup && rm $WORK_DIR/setup
    test -e $WORK_DIR/custom && rm $WORK_DIR/custom
    test $PTS_MOUNTED -eq 1 && umount $WORK_DIR/dev/pts
    test $DEV_MOUNTED -eq 1 && umount $WORK_DIR/dev
    test $PROC_MOUNTED -eq 1 && umount $WORK_DIR/proc
    test $SYS_MOUNTED -eq 1 && umount $WORK_DIR/sys
    test $RUN_MOUNTED -eq 1 && umount $WORK_DIR/run
    test $BOOT_MOUNTED -eq 1 && umount $WORK_DIR/boot
    test $ROOT_MOUNTED -eq 1 && umount $WORK_DIR
    test $WORK_DIR_CREATED -eq 1 && rmdir $WORK_DIR
    test $VG_CREATED -eq 1 && vgchange -an $VG_NAME > /dev/null
    test $LUKS_OPENED -eq 1 && cryptsetup luksClose $LVM_DEVICE_PATH
    test $VOLUME_ATTACHED -eq 1 && aws ec2 detach-volume --volume-id=$VOLUME > /dev/null && \
        wait_for_volume $VOLUME "available"
    rm -f info
}

image_delete()
{
    test $IMAGE_DELETE_DONE -eq 1 && return

    if [[ $IMAGE_CREATED -eq 1 ]]
    then
        if [[ $KEEP_IMAGE -eq 0 ]]
        then
            aws ec2 deregister-image --image-id=$IMAGE > /dev/null && \
                wait_for_image $IMAGE ""
        else
            echo "Skip deregistering image $IMAGE"
        fi
    fi

    if [[ $SNAPSHOT_CREATED -eq 1 ]]
    then
        if [[ $KEEP_IMAGE -eq 0 ]]
        then
            aws ec2 delete-snapshot --snapshot-id=$SNAPSHOT > /dev/null && \
                wait_for_snapshot $SNAPSHOT ""
        else
            echo "Skip deleting snapshot $SNAPSHOT"
        fi
    fi
}

volume_delete()
{
    test $VOLUME_DELETE_DONE -eq 1 && return
    test $VOLUME_CREATED -eq 1 && aws ec2 delete-volume --volume-id=$VOLUME > /dev/null && \
        wait_for_volume $VOLUME ""
}

fail() 
{ 
    MESSAGE=$1

    test ! -z "$MESSAGE" && echo $MESSAGE
    test -e error.out && cat error.out 1>&2

    echo Cleaning up
    image_delete
    volume_cleanup
    volume_delete

    echo Failed
    exit 1
}

check_requirements()
{
    FAIL=0

    test -z "$LUKS_PASSWORD"            && FAIL=1 && \
        echo "LUKS password needs to be exported in LUKS_PASSWORD environmennt variable"
    test -e $WORK_DEVICE                && FAIL=1 && echo "Work device $WORK_DEVICE is already used"
    test -e $WORK_DIR                   && FAIL=1 && echo "Work mount point $WORK_DIR already exists"
    test -e /dev/$VG_NAME               && FAIL=1 && echo "Volume group $VG_NAME already exists"
    test -e /dev/$VG_NAME/$LV_NAME_SWAP && FAIL=1 && echo "Logical volume $LV_NAME_SWAP already exists"
    test -e /dev/$VG_NAME/$LV_NAME_ROOT && FAIL=1 && echo "Logical volume $LV_NAME_ROOT already exists"
    test -e $LVM_DEVICE_PATH            && FAIL=1 && echo "LVM_DEVICE $LVM_DEVICE_PATH already exists"
    test ! -e /usr/bin/jq               && FAIL=1 && echo "Package jq is required"
    test ! -e /usr/bin/aws              && FAIL=1 && echo "Package awscli is required"

    test $FAIL -eq 1 && fail
    return 0
}

for VAR in VOLUME_CREATED VOLUME_ATTACHED LUKS_OPENED VG_CREATED WORK_DIR_CREATED ROOT_MOUNTED \
    BOOT_MOUNTED PTS_MOUNTED DEV_MOUNTED PROC_MOUNTED SYS_MOUNTED RUN_MOUNTED IMAGE_DELETE_DONE \
    VOLUME_CLEANUP_DONE VOLUME_DELETE_DONE SNAPSHOT_CREATED IMAGE_CREATED
do
    export $VAR=0
done
trap fail ERR INT TERM

while read LINE
do
    test -z $(echo $LINE | grep '.' | grep -v "^#") && continue
    export $LINE
done < <(grep . aws2luks.conf | grep -v '^#')

export LVM_DEVICE_PATH=/dev/mapper/$LVM_DEVICE

check_requirements

AWS_URL=http://169.254.169.254/latest
curl -s $AWS_URL/dynamic/instance-identity/document > info
THIS_INSTANCE=$(jq -r '.instanceId' < info)
ZONE=$(jq -r '.availabilityZone' < info)
export AWS_DEFAULT_REGION=$(jq -r '.region' < info)

echo Creating a volume
aws ec2 create-volume --availability-zone=$ZONE --volume-type=$VOLUME_TYPE --size=$TARGET_SIZE_GB > info
VOLUME=$(jq -r '.VolumeId' < info)
VOLUME_CREATED=1

wait_for_volume $VOLUME "available"

AWS_DEVICE=$(echo $WORK_DEVICE | sed "s/\/dev\/xvd/\/dev\/sd/g")
aws ec2 attach-volume --volume-id=$VOLUME --instance-id=$THIS_INSTANCE --device=$AWS_DEVICE > /dev/null
VOLUME_ATTACHED=1

wait_for_volume $VOLUME "in-use"
wait_for_device $WORK_DEVICE

parted -s -a optimal $WORK_DEVICE                \
    mklabel msdos                                \
    mkpart primary ext2 0% ${BOOT_SIZE_MB}MiB    \
    set 1 boot on                                \
    mkpart primary ext2 ${BOOT_SIZE_MB}MiB 100%

BOOT_DEVICE=${WORK_DEVICE}1
mke2fs -q -t $BOOT_FS_TYPE -L $BOOT_LABEL $BOOT_DEVICE

LUKS_DEVICE=${WORK_DEVICE}2
echo -n $LUKS_PASSWORD | cryptsetup luksFormat $LUKS_DEVICE -
echo -n $LUKS_PASSWORD | cryptsetup -d - luksOpen $LUKS_DEVICE $LVM_DEVICE; LUKS_OPENED=1

if [[ $RANDOMIZE -eq 1 ]]
then
    echo "Seeding encrypted device with random data"
    RANDOM=$(dd if=/dev/urandom bs=16 count=1 status=none | base64)
    openssl aes-128-cbc -nosalt -k "$RANDOM" -in /dev/zero 2> /dev/null |
        dd of=$LVM_DEVICE_PATH bs=64k status=none 2> /dev/null \
        || true
fi

pvcreate -f $LVM_DEVICE_PATH > /dev/null
vgcreate -f $VG_NAME $LVM_DEVICE_PATH > /dev/null; VG_CREATED=1

if [[ $SWAP_SIZE_MB -ne 0 ]]
then
    SWAP_DEVICE=/dev/mapper/${VG_NAME}-${LV_NAME_SWAP}
    lvcreate -L ${SWAP_SIZE_MB}M -n $LV_NAME_SWAP $VG_NAME > /dev/null
    mkswap -f -L $SWAP_LABEL $SWAP_DEVICE > /dev/null
fi

ROOT_DEVICE=/dev/mapper/${VG_NAME}-${LV_NAME_ROOT}
lvcreate -L ${ROOT_SIZE_MB}M -n $LV_NAME_ROOT $VG_NAME > /dev/null

OS_ARCHIVE=$(basename $OS_URL)

if [[ -e $OS_ARCHIVE ]]
then
    echo "Verifying archive hash"
    LOCAL_HASH=$(sha256sum $OS_ARCHIVE | awk '{print $1}')
    REMOTE_HASH=$(curl -s $OS_SHA256 | grep $OS_ARCHIVE | awk '{print $1}')

    if [[ "$LOCAL_HASH" == "$REMOTE_HASH" ]]
    then
        echo "Verified SHA256: $LOCAL_HASH"
    else
        echo "Local and remote hash do not match"
        rm $OS_ARCHIVE
    fi
fi

if [[ ! -e $OS_ARCHIVE ]]
then
    echo "Downloading the OS image"
    curl -# -o $OS_ARCHIVE $OS_URL
fi

echo "Writing the OS image"
OS_SIZE=$(gzip -l $OS_ARCHIVE | tail -1 | awk '{print $2}')
tar xfz $OS_ARCHIVE -O $OS_IMAGE | dd of=$ROOT_DEVICE bs=64k status=none
e2label $ROOT_DEVICE $ROOT_LABEL > /dev/null
tune2fs $ROOT_DEVICE -U random > /dev/null
resize2fs $ROOT_DEVICE > /dev/null 2> error.out; rm error.out

mkdir $WORK_DIR; WORK_DIR_CREATED=1
mount -L $ROOT_LABEL $WORK_DIR; ROOT_MOUNTED=1
mv $WORK_DIR/boot $WORK_DIR/boot.original
mkdir $WORK_DIR/boot
mount -L $BOOT_LABEL $WORK_DIR/boot; BOOT_MOUNTED=1

mv $WORK_DIR/boot.original/*-generic $WORK_DIR/boot
rm -rf $WORK_DIR/boot.original

KEY_ENTRY=$(curl -s $AWS_URL/meta-data/public-keys/ | grep $SSH_KEY | cut -f 1 -d '=')

if [[ ! -z "$KEY_ENTRY" ]]
then
    KEY_IDENT=$(curl -s $AWS_URL/meta-data/public-keys/$KEY_ENTRY/)
    mkdir -p $WORK_DIR/etc/initramfs-tools/root/.ssh
    curl -s $AWS_URL/meta-data/public-keys/$KEY_ENTRY/$KEY_IDENT \
        > $WORK_DIR/etc/initramfs-tools/root/.ssh/authorized_keys
    chmod -R 0700 $WORK_DIR/etc/initramfs-tools/root/.ssh
else
    echo "SSH key $SSH_KEY not found"
    fail
fi

cat <<EOT > $WORK_DIR/etc/fstab
LABEL=$SWAP_LABEL  swap   swap  defaults  0  0
LABEL=$BOOT_LABEL  /boot  ext4  defaults  0  0
LABEL=$ROOT_LABEL  /      ext4  defaults  0  0
EOT

LUKS_DEV_UUID=$(blkid -s UUID -o value $LUKS_DEVICE)
CFG_DIR=$WORK_DIR/etc/default
CMDLINE="cryptdevice=UUID=$LUKS_DEV_UUID:$LVM_DEVICE"

sed "s/GRUB_CMDLINE_LINUX=\".*\"/GRUB_CMDLINE_LINUX=\"$CMDLINE\"/g" $CFG_DIR/grub > $CFG_DIR/grub.new
mv $CFG_DIR/grub.new $CFG_DIR/grub

cat <<EOT > $WORK_DIR/etc/crypttab
$LVM_DEVICE UUID=$LUKS_DEV_UUID none luks
EOT

mount --bind /dev $WORK_DIR/dev;          DEV_MOUNTED=1
mount --bind /dev/pts $WORK_DIR/dev/pts;  PTS_MOUNTED=1
mount --bind /proc $WORK_DIR/proc;        PROC_MOUNTED=1
mount --bind /sys $WORK_DIR/sys;          SYS_MOUNTED=1
mount --bind /run $WORK_DIR/run;          RUN_MOUNTED=1

cat <<EOT > $WORK_DIR/setup
#!/bin/bash
fail() { test -e error.out && (cat error.out 1>&2; rm error.out); exit 1; }
trap fail ERR INT TERM
apt-get -qq update > /dev/null 2> error.out; rm error.out
apt-get -qq install busybox dropbear > /dev/null 2> error.out; rm error.out
grub-install $WORK_DEVICE > /dev/null 2> error.out; rm error.out
update-grub 2> error.out; rm error.out
update-initramfs -u > /dev/null 2> error.out; rm error.out
test -e /custom && /custom
exit
EOT
chmod +x $WORK_DIR/setup

if [[ -e $CUSTOM_SCRIPT ]]
then
    cp $CUSTOM_SCRIPT $WORK_DIR/custom
    chmod +x $WORK_DIR/custom
fi

echo "Setting up the OS"
chroot $WORK_DIR bash -i ./setup
volume_cleanup; VOLUME_CLEANUP_DONE=1

echo "Creating snapshot (very slow)"
aws ec2 create-snapshot --volume-id=$VOLUME > info
SNAPSHOT=$(jq -r '.SnapshotId' < info)
SNAPSHOT_CREATED=1
wait_for_snapshot $SNAPSHOT "completed"

echo "Registering image"
aws ec2 register-image --name=$SNAPSHOT --root-device-name=/dev/sda1 \
    --block-device-mappings="DeviceName=/dev/sda1,Ebs={SnapshotId=$SNAPSHOT,VolumeType=$VOLUME_TYPE}" \
    --virtualization-type=hvm --architecture=x86_64 > info
IMAGE=$(jq -r '.ImageId' < info)
IMAGE_CREATED=1
wait_for_image $IMAGE "available"

echo "Creating Instance"
aws ec2 run-instances --instance-type $INSTANCE_TYPE --image-id=$IMAGE --key-name=$SSH_KEY > info
INSTANCE=$(jq -r '.Instances[].InstanceId' < info)
wait_for_instance $INSTANCE

image_delete; IMAGE_DELETE_DONE=1
volume_delete; VOLUME_DELETE_DONE=1

